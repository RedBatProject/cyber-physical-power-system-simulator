This Python simulator is designed for cyber-physical power grid systems and consists of two main files: `modules.py`, which contains all the necessary modules for creating a network from data, adding renewable energy sources, and managing capacity.

Function: `Initial(casename='118', case=1)`
This function initializes the power and communication network using CSV files that contain the relevant data. The parameter `casename` refers to the power network case, such as 118 or 145; however, the current implementation only supports the 118 case. The `case` parameter allows users to select from five sample networks that have been created based on the original network.

Function: `add_renew(bus, senario1='hbtc', senario2='_', renew=0.1, renew2=0.1)`
This function enhances the power network by adding renewable energy capacity to the buses generated by the `Initial` function. The `senario1` parameter determines whether to add capacity to buses with high betweenness centrality or high degree. The `senario2` parameter specifies whether to apply the capacity increase only to load nodes, generator nodes, or both. The `renew` parameter indicates the amount of renewable capacity to be distributed among the selected buses, while `renew2` specifies the number of buses to be selected for this enhancement.



Function: `slackid(busses)`
This function takes a list of buses as input and returns the identifier of the slack bus.

Function: `slackvalue(busses)`
This function receives the buses and returns the capability of each bus to be considered as a slack bus.

Function: `demand(busses)`
This function calculates and returns the demand for the given buses.

Function: `LoadBalancingS(bus, slack_bus_)`
This function accepts the buses and the slack bus as inputs, returning a balanced network. It is designed to balance the network only once, relying solely on the slack bus to perform the balancing task, provided it is sufficient.

Function: `Init(lines, busses)`
This function takes the lines and buses of the power network, solves the DC power flow equations, and returns the network along with its line flows and maximum capacities. For additional information, please refer to Chapter 3 of the thesis.

Function: `DCPower(busses, lines, slack_bus)`
This function calculates the DC power flow for the specified buses and lines, utilizing the slack bus. It is used whenever a power flow calculation is needed without any optimization.

To facilitate the separation of communication and power networks, we have implemented a function named `B2LL2B`, which provides the buses and lines for each network and checks whether both sets are equal.



Function: `betweenLayercascade(netB, netL, netC, netCl)`
This function takes the buses and lines from both networks as input, facilitates the cascading effects between the two networks, and returns the final configurations of both networks.

Function: `CascadeInPow(net, line)`
This function receives the lines and buses of the power grid and simulates cascading failures within the power grid. It utilizes two additional functions:
1. `DCPowerOP`: This function is responsible for optimal load shedding in the power grid.
2. `DCPower`: This function simply calculates the DC power flow within the power network.

Function: `DCPowerOP`
This function prepares the power grid for another function, **`optc(busses, lines, slack_bus)`**, which optimally balances the load in the power grid. This is a crucial part of the simulation, as it focuses on the optimization process. 

In this simulation, we employ the command `prob.solve(solver=cp.SCIPY)`, using "SCIPY" as the solver. This solver is known for its speed and efficiency in handling problems with numerous variables, and it is also available for free.
